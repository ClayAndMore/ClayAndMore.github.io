<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="我在 Github 上的个人博客">
    <meta name="keyword" content="null">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="http://ojynuthay.bkt.clouddn.com/titleImg.png">
    <link rel="alternate" type="application/atom+xml" title="Claymore" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        c#网络编程｜Claymore&#39;s blog
        
    </title>

    <link rel="canonical" href="https://clayandmore.github.io/2016/05/30/c#网络编程/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('http://ojynuthay.bkt.clouddn.com/backtest.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Claymore
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/AboutMe/">aboutme</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/tags/">tags</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/archives/">archives</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="http://ojynuthay.bkt.clouddn.com/moudleBack.jpg">


<style>
    
    header.intro-header {
        background-image: url('http://ojynuthay.bkt.clouddn.com/moudleBack.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>c#网络编程</h1>
                    
                    <span class="meta">
                         作者 Claymore
                        <span>
                          日期 2016-05-30
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#c#"
                           title="c#">c#</a>
                        
                        <a class="tag" href="/tags/#网络编程"
                           title="网络编程">网络编程</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            c#网络编程
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p>1.Socket类</p>
<ul>
<li>位于System.Net.Sockets命名空间</li>
<li>构造函数定义：<br>  <code>Socket localSocket = new Socket(AddressFamily。InterNetwork,SocketType.Stream,ProtocolType.Tcp);</code><br>  上面是tcp面向连接的通信，后两位参数改成:<br>  <code>SocketType.Dgram,ProtocolType.UDP</code><br>  为无连接的udp通信</li>
<li>在Internet中，TCP/IP 使用一个网络地址和一个服务端口号来唯一标识设备。网络地址标识网络上的特定设备；端口号标识要连接到的该设备上的特定服务。网络地址和服务端口的组合称为终结点，在 .NET 框架中正是由<strong>EndPoint</strong> 类表示这个终结点，它提供表示网络资源或服务的抽象，用以标志网络地址等信息。.Net同时也为每个受支持的地址族定义了 EndPoint 的子代；对于 IP 地址族，该类为 IPEndPoint</li>
</ul>
<a id="more"></a>
<ul>
<li>对于服务器<ol>
<li>实例化Socket对象，建立一个套接字</li>
<li>绑定本地IP端口作为服务器端。Bind方法绑定本地<strong>终结点</strong>。指定一个本地ip和本地端口，socket将在该终结点上监听传入的客户端连接。</li>
<li>Listen方法开始监听客户端连接，监听网络上是否有人给自己发送东西，这里跳到客户端的1.</li>
<li>Accept相关方法接受连接，返回与客户端通信的Socket实例。这个实例用于客户端通信，而不是上面用于监听的Socket。</li>
<li>通过Send和Receive方法进行收发数据。</li>
<li>通信结束后用Close关闭sSocket对象</li>
</ol>
</li>
<li>对于客户端<ol>
<li>调用connect方法进行连接，需要指定服务器的地址和端口（必须与服务器绑定监听的接口一致），对于UDP，可不用进行连接。</li>
<li>Send和Receive方法收发数据。 对于未连接的socket对象(UDP)，用SendTo和ReceiveFrom。</li>
<li>通信结束关闭socket对象</li>
</ol>
</li>
</ul>
<p><img src="http://7xs1eq.com1.z0.glb.clouddn.com/socket.png" alt=""></p>
<ul>
<li><p>一个同步通信（UDP）的示例：两个VS项目，一个接受端，一个发送端<br>发送端：</p>
<pre><code>using System;
using System.Text;
using System.Net;
using System.Net.Sockets;

namespace synSocketUDP1
{
    class UDPSending
    {
        public void Display()
        {
            //定义发送字节区
            byte[] byteArray = new byte[100];
            //定义网络地址
            IPEndPoint iep = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 1000);
            Socket socket1 = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            //发送数据
            Console.WriteLine(&quot;请输入要发送的数据&quot;);
            EndPoint ep = (IPEndPoint)iep;
            while (true)
            {
                string strMsg = Console.ReadLine();
                //字节转换
                byteArray = Encoding.Default.GetBytes(strMsg);
                socket1.SendTo(byteArray, ep);
                if(strMsg==&quot;exit&quot;)
                {
                    break;
                }
            }
            socket1.Shutdown(SocketShutdown.Both);
            socket1.Close();
        }

        static void Main(string[] args)
        {
            UDPSending obj = new UDPSending();
            Console.WriteLine(&quot;---发送端----&quot;);
            obj.Display();
        }
    }
}
</code></pre><p>接收端：</p>
<pre><code>using System;
using System.Text;
using System.Net;
using System.Net.Sockets;

namespace synSocketUDP2
{
    class UDPReceiving
    {
        public void Display()
        {
            //定义接受的数据
            byte[] byteArray = new byte[100];
            //定义网络地址
            IPEndPoint iep = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;),1000);
            Socket socket2 = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket2.Bind(iep);//绑定地址（服务器端）
            //接受数据
            EndPoint ep = (IPEndPoint)iep;
            while (true)
            {
                int intReceiveLength = socket2.ReceiveFrom(byteArray, ref ep);
                string strReceiveStr = Encoding.Default.GetString(byteArray, 0, intReceiveLength);
                Console.WriteLine(strReceiveStr);
            }

        }

        static void Main(string[] args)
        {
            UDPReceiving obj = new UDPReceiving();
            Console.WriteLine(&quot;接收端&quot;);
            obj.Display();
        }
    }
}
</code></pre><p><img src="http://7xs1eq.com1.z0.glb.clouddn.com/SynUdpDisplay.png" alt=""></p>
</li>
<li><p>下面是一个异步通信的UDP实例：</p>
<pre><code>using System;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace asynSocketUDP1
{
    class asynUDPTalk
    {
        //定义状态
        bool boolSendingFlag = true;
        bool boolReceivingFlag = true;

        IPEndPoint iep = null;
        IPEndPoint iep_Receive = null;
        Socket socketSend = null;
        Socket socketReceive = null;

        byte[] byteSendArray = null;
        byte[] byteReceiveArray = null;

        static void Main(string[] args)
        {
            asynUDPTalk obj = new asynUDPTalk();

            Console.WriteLine(&quot;———————我是哈哈哈——————&quot;);
            obj.Display();

        }
        public void Display()
        {
            Thread SendThread = new Thread(SendData);
            Thread ReceiveThread = new Thread(ReceiveDate);

            SendThread.Start();
            ReceiveThread.Start();
        }
        //发送线程方法
        public void SendData()
        {
            Thread.Sleep(500);//休眠0.5秒，不知道这样有何用意
            if (boolSendingFlag)
            {
                //定义发送字节
                byteSendArray = new byte[100];
                //定义网络地址
                iep = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 1001);
                socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                boolSendingFlag = false;
            }
            //发送数据
            Console.WriteLine(&quot;请输入要发送的数据：&quot;);
            EndPoint ep = (EndPoint)iep;
            while (true)
            {
                string strMsg = Console.ReadLine();
                //字节转换
                byteSendArray = Encoding.Default.GetBytes(strMsg);
                socketSend.SendTo(byteSendArray, ep);
                if(strMsg==&quot;exit&quot;)
                {
                    break;
                }
            }

            socketSend.Shutdown(SocketShutdown.Both);
            socketSend.Close();

        }
        //接受线程方法
        public void ReceiveDate()
        {
            if(boolReceivingFlag)
            {
                //定义接收数据区
                byteReceiveArray = new byte[100];
                //定义网络地址
                iep_Receive = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 1002);
                socketReceive = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                socketReceive.Bind(iep_Receive);
                boolReceivingFlag = false;
            }

            //接受数据
            EndPoint ep = (EndPoint)iep_Receive;
            while (true)
            {
                int intReceiveLength = socketReceive.ReceiveFrom(byteReceiveArray, ref ep);
                string strReceive = Encoding.Default.GetString(byteReceiveArray, 0, intReceiveLength);
                Console.WriteLine(strReceive);

            }
        }
    }
}
</code></pre><p>另一个客户端跟上面代码一样，不过要把这个接受端的端口号和另一个发送端口号对应，这个的发送端也是一样。<br>运行效果：<br><img src="http://7xs1eq.com1.z0.glb.clouddn.com/asynSocketUdp.png" alt=""></p>
</li>
</ul>
<hr>
<p>###上面的是自己动手做的，下面的是网上的</p>
<ul>
<li><p>示例（TCP)。在vs中新建一个解决方案，包含两个控制台应用项目，运行时在方案属性中可以调成多项目启动。</p>
<ol>
<li><p>服务端</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Net.Sockets;

namespace ServerApp
{
    class Program
    {
        static void Main(string[] args)
        {
            // 1、实例化Socket对象
            Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            // 2、定义本地终结点
            IPEndPoint endpoint = new IPEndPoint(IPAddress.Any, 1332);
            // 3、绑定本地终结点
            server.Bind(endpoint);
            Console.WriteLine(&quot;已经绑定到本地终结点{0}。&quot;);
            // 4、监听客户端连接
            server.Listen(15);  //15为最大连接数
            Console.WriteLine(&quot;等待客户端连接……&quot;);
            // 5、接受客户端连接
            server.BeginAccept(new AsyncCallback(AccpCallback), server);  //开启异步编程
            Console.WriteLine(&quot;请按ESC键退出。&quot;);
            while (Console.ReadKey().Key != ConsoleKey.Escape) ;
            // 6、关闭Socket
            server.Close();
        }

        private static void AccpCallback(IAsyncResult ar)
        {
            Socket server = (Socket)ar.AsyncState;
            // 返回表示客户端连接的Socket
            Socket client = server.EndAccept(ar);
            Console.WriteLine(&quot;已接受客户端{0}的连接。&quot;, client.RemoteEndPoint.ToString());
            // 向客户端发送一条消息
            byte[] data = Encoding.UTF8.GetBytes(&quot;您好，服务器已经接受连接了。&quot;);
            // 先发送内容的长度
            int len = data.Length;
            client.Send(BitConverter.GetBytes(len));
            // 然后发送内容正文
            client.Send(data);
            // 关闭Socket
            client.Close();
            // 继续接受连接
            server.BeginAccept(new AsyncCallback(AccpCallback), server);
        }
    }
}
</code></pre></li>
</ol>
</li>
</ul>
<pre><code>2. 客户端

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Text;
        using System.Threading.Tasks;

        using System.Net;
        using System.Net.Sockets;

        namespace ClientApp
        {
            class Program
            {
                static void Main(string[] args)
                {
                    // 1、实例化Socket对象
                    Socket client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  //参数先记下，最后一个参数可改tcp或udp
                    try
                    {
                        // 2、连接服务器
                        client.Connect(&quot;127.0.0.1&quot;, 1332);
                        Console.WriteLine(&quot;成功连接服务器{0}。&quot;, client.RemoteEndPoint.ToString());
                        // 3、接收服务器发来的消息
                        // 先读取4个字节，得到消息长度
                        byte[] buffer = new byte[4];
                        client.Receive(buffer);
                        int len = BitConverter.ToInt32(buffer, 0);
                        // 开始接收正文
                        buffer = new byte[len];
                        client.Receive(buffer);
                        string msg = Encoding.UTF8.GetString(buffer);
                        Console.WriteLine(&quot;从服务器接收到的消息：\n&quot; + msg);
                    }
                    catch (SocketException ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                    Console.Read();
                }
            }
        }
3. 上例在发送消息时，将消息长度int转化为字节数组发送出去，然后才接受内容，接收的时候，先读出4个字节，转换为int值，再读取消息内容，这样做防止粘包问题。
</code></pre><ul>
<li><p>实例（UDP)<br>  1.服务端</p>
<pre><code>using System;
using System.Text;
using System.Net;
using System.Net.Sockets;
namespace server
{
    class AsyncUdpServer
    {

        private static Socket serverSocket; //服务器端Socket对象

        private static byte[] receiveData = new byte[1024]; //接收数据的字符数组

        static string Smsg=&quot;hello&quot;;     //服务器要发送的消息

        public static void Main(string[] args)
        {
            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp); //实例化服务器端Socket对象
            //服务器端的IP和端口，IPAddress.Any实际是：0.0.0.0，表示任意，基本上表示本机IP
            IPEndPoint server = new IPEndPoint(IPAddress.Any, 11000);

            serverSocket.Bind(server);        //Socket对象跟服务器端的IP和端口绑定

            IPEndPoint clients = new IPEndPoint(IPAddress.Any, 0);   //客户端的IP和端口，端口 0 表示任意端口

            EndPoint epSender = (EndPoint)clients;          //实例化客户端 终点

            //开始异步接收消息  接收后，epSender存储的是发送方的IP和端口
            serverSocket.BeginReceiveFrom(receiveData, 0, receiveData.Length, SocketFlags.None,
                ref epSender, new AsyncCallback(ReceiveData), epSender);
            Console.WriteLine(&quot;Listening...&quot;);
            while (true)
            {
                Smsg = Console.ReadLine();
                if (Smsg == &quot;exit&quot;) break;
            }

        }

        private static void ReceiveData(IAsyncResult iar)
        {

            IPEndPoint client = new IPEndPoint(IPAddress.Any, 0);   //客户端的IP和端口，端口 0 表示任意端口

            EndPoint epSender = (EndPoint)client;           //实例化客户端 终点

            int recv = serverSocket.EndReceiveFrom(iar, ref epSender);     //结束异步接收消息  recv 表示接收到的字符数
</code></pre></li>
</ul>
<pre><code>Console.WriteLine(&quot;Client:&quot; + Encoding.ASCII.GetString(receiveData, 0, recv));//将接收到的数据打印出来，发送方采用什么编码方式，此处就采用什么编码方式 转换成字符串
</code></pre><p>  ​<br>  ​<br>                        //定义要发送回客户端的消息，采用ASCII编码，如果要发送汉字或其他特殊符号，可以采用UTF-8<br>                        byte[] sendData = Encoding.ASCII.GetBytes(Smsg);<br>                            //开始异步发送消息  epSender是上次接收消息时的客户端IP和端口信息<br>                            serverSocket.BeginSendTo(sendData, 0, sendData.Length, SocketFlags.None,<br>                                epSender, new AsyncCallback(SendData), epSender);</p>
<pre><code>                        receiveData = new byte[1024];  //重新实例化接收数据字节数组

                        //开始异步接收消息，此处的委托函数是这个函数本身，递归                               
                    serverSocket.BeginReceiveFrom(receiveData, 0, receiveData.Length, SocketFlags.None,
                            ref epSender, new AsyncCallback(ReceiveData), epSender);
                    }

                private static void SendData(IAsyncResult iar)
                {
                    serverSocket.EndSend(iar);
                }
            }
        }
2.客户端

    using System;
    using System.Net.Sockets;
    using System.Net;
    using System.Text;

    namespace client
    {
        class Program
        {

            private static Socket clientSocket;         //客户端 Socket对象

            private static EndPoint epServer;           //服务器端 终点

            private static byte[] receiveData;          //接收数据的字符数组
            public static void Main(string[] args)
            {
                clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);  //客户端Socket对象实例化

                IPEndPoint server = new IPEndPoint(IPAddress.Parse(&quot;172.24.15.42&quot;), 11000);                 //设置服务器端IP地址和对应端口

                epServer = (EndPoint)server;             //实例化服务器端 终点
                string msg;                              //要发送的消息
                byte[] sendData;                         //要发送的字符串
                while (true)
                {
                    msg = Console.ReadLine();            //输入要发送的消息
                    if (msg == &quot;exit&quot;) break;            //当输入“exit”时，退出客户端程序
                    //将消息通过ASCII编码转换为字符数组，
                    //如果要发送汉字或其他特殊符号，可以采用UTF-8 
                    sendData = Encoding.ASCII.GetBytes(msg);
                    //开始异步发送消息
                    //参数：sendData           要发送的数据
                    //参数：0：                 要发送数据的起始位置
                    //参数：sendData.Length：   要发送数据的字节数
                    //参数：SocketFlags.None：  按位组合方式
                    //参数：epServer：          接收方设备（包含IP和端口）
                    //参数：new AsyncCallback(SendData):   委托
                    //参数：null：          请求的状态信息
                    clientSocket.BeginSendTo(sendData, 0, sendData.Length, SocketFlags.None,
                        epServer, new AsyncCallback(SendData), null);
                    //实例化接收数据的字符数组
                    //若在声明时已经初始化，此处依然要进行重新初始化
                    //当上次接收的数据长度大于本次，则该数组里包含上次接收的残留数据
                    //比如：上次接收“你个小逗逼”。本次接收“开玩笑”。
                    //则数组中的数据为：“开玩笑逗逼”。
                    receiveData = new byte[1024];
                    //开始异步接收消息
                    //参数部分与异步发送部分对应，基本一致
                    clientSocket.BeginReceiveFrom(receiveData, 0, receiveData.Length, SocketFlags.None,
                        ref epServer, new AsyncCallback(ReceiveData), null);
                }
            }

            private static void SendData(IAsyncResult iar)            //异步发送消息的委托函数
            {

                clientSocket.EndSend(iar);                            //完成异步发送
            }

            private static void ReceiveData(IAsyncResult iar)         //异步接收消息的委托函数
            {

                int recv = clientSocket.EndReceive(iar);              //完成异步接收  recv 表示接收到的字节数

                Console.WriteLine(&quot;Server: &quot; + Encoding.ASCII.GetString(receiveData, 0, recv));    //将接收到的数据打印出来
            }
        }
    }
</code></pre><p>2.TcpListener类和TcpClient类<br>待补充<br>3.UdpClient类    </p>

                <hr>
                
                <!-- 多说 Share start -->
                <div class="ds-share"
                     style="text-align: right"
                     data-thread-key="2016/05/30/c#网络编程/"
                     data-title="c#网络编程"
                     data-url="https://clayandmore.github.io/2016/05/30/c#网络编程/"
                     data-images=""
                     data-content="Socket编程1.Socket类

位于System.Net.Sockets命名空间
构造函... | Claymore&#39;s blog ">
                    <div class="ds-share-inline">
                        <ul class="ds-share-icons-16">
                            <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                            <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                            <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                            <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                        </ul>
                        <div class="ds-share-icons-more">
                        </div>
                    </div>
                    <hr>
                </div>
                <!-- 多说 Share end-->
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/06/03/unity函数和细节整理/" data-toggle="tooltip" data-placement="top"
                           title="unity函数和细节整理">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2016/05/25/设计模式/" data-toggle="tooltip" data-placement="top"
                           title="设计模式">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                         data-thread-key="2016/05/30/c#网络编程/"
                         data-title="c#网络编程"
                         data-url="https://clayandmore.github.io/2016/05/30/c#网络编程/">
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket编程"><span class="toc-text">Socket编程</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#c#"
                           title="c#">c#</a>
                        
                        <a class="tag" href="/tags/#网络编程"
                           title="网络编程">网络编程</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://lfkid.github.io/">锋</a></li>
                        
                        <li><a href="https://clayandmore.github.io/">自我测试</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User by Hux
    var _user = 'claymoreforblog';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user};
    (function () {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->





<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/claymoreTT">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/wangyu-1994">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/422516721">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/clayandmore">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Claymore 2017
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://clayandmore.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','null','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://ojynuthay.bkt.clouddn.com/header.jpg">
</body>

</html>
