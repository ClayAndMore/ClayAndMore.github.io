<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="我在 Github 上的个人博客">
    <meta name="keyword" content="null">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="http://ojynuthay.bkt.clouddn.com/titleImg.png">
    <link rel="alternate" type="application/atom+xml" title="Claymore" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        python基础整理｜Claymore&#39;s blog
        
    </title>

    <link rel="canonical" href="https://clayandmore.github.io/2017/01/30/python基础整理/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('http://ojynuthay.bkt.clouddn.com/backtest.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Claymore
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/archives/">archives</a>
                        </li>
							
						
                    
                        
							
                        <li>
                            <a href="/tags/">tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="http://ojynuthay.bkt.clouddn.com/moudleBack.jpg">


<style>
    
    header.intro-header {
        background-image: url('http://ojynuthay.bkt.clouddn.com/moudleBack.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>python基础整理</h1>
                    
                    <span class="meta">
                         作者 Claymore
                        <span>
                          日期 2017-01-30
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#python"
                           title="python">python</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            python基础整理
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <p>python的哲学：</p>
<p><code>用一种方法，最好是只有一种方法来做一件事。</code></p>
<p>linux 命令行将以\$开始，比如\$ls,$python<br>python命令行将以&gt;&gt;&gt;开始 如：&gt;&gt;&gt;print ‘Hello World!’<br>注释会以#开始<br>文件后缀.py<br>一行写不下可以用+\连接</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。</p>
<p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p>
<ul>
<li>CPython</li>
</ul>
<p>当我们从Python官方网站下载并安装好Python 3.5后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</p>
<p>CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p>
<ul>
<li>IPython</li>
</ul>
<p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p>
<p>CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</p>
<ul>
<li>PyPy</li>
</ul>
<p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p>
<p>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</p>
<ul>
<li>Jython</li>
</ul>
<p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<ul>
<li>IronPython</li>
</ul>
<p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
<h3 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h3><p>输出<code>print()</code></p>
<p>输入<code>input(&#39;请输入您要输入的内容&#39;)</code></p>
<p>一个有问题的条件判断。很多同学会用<code>input()</code>读取用户的输入，这样可以自己输入，程序运行得更有意思：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">birth = input(&apos;birth: &apos;)</div><div class="line">if birth &lt; 2000:</div><div class="line">    print(&apos;00前&apos;)</div><div class="line">else:</div><div class="line">    print(&apos;00后&apos;)</div></pre></td></tr></table></figure>
<p>输入<code>1982</code>，结果报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: unorderable types: str() &gt; int()</div></pre></td></tr></table></figure>
<p>这是因为<code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来完成这件事情：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s = input(&apos;birth: &apos;)</div><div class="line">birth = int(s)</div><div class="line">if birth &lt; 2000:</div><div class="line">    print(&apos;00前&apos;)</div><div class="line">else:</div><div class="line">    print(&apos;00后&apos;)</div></pre></td></tr></table></figure>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p>
<p>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</div><div class="line">&apos;Hello, world&apos;</div><div class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</div><div class="line">&apos;Hi, Michael, you have $1000000.&apos;</div></pre></td></tr></table></figure>
<p>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p>
<p>常见的占位符有：</p>
<table>
<thead>
<tr>
<th>%d</th>
<th>整数</th>
</tr>
</thead>
<tbody>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody>
</table>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)</div><div class="line">&apos; 3-01&apos;</div><div class="line">&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926  #会四舍五入</div><div class="line">&apos;3.14&apos;</div></pre></td></tr></table></figure>
<p>如果你不太确定应该用什么，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)</div><div class="line">&apos;Age: 25. Gender: True&apos;</div></pre></td></tr></table></figure>
<p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</div><div class="line">&apos;growth rate: 7 %&apos;</div></pre></td></tr></table></figure>
<p>输出时注意前面不要有逗号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a=<span class="string">'abc'</span></div><div class="line">print(<span class="string">'hello,%s!'</span>%a) <span class="comment">#%a前不要有逗号</span></div></pre></td></tr></table></figure>
<h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"&lt;用户名 '&#123;&#125;'，邮箱 '&#123;&#125;'"</span>.format(self.username,self.email)</div></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量不需要声明，直接 a=10,<br>type(a)，可以看变量的类型<br>收回变量直接赋新值就好<br>在python3中，一个int类型可以存任意大小的整数，甚至超过了64位，但是超出一定范围就直接表示为<code>inf</code>（无限大）。<br>None和False不一样。</p>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><ul>
<li><p>tuple，定值表 ，也成为元组，s1=(1,2,true)  其中的值不可变更</p>
<p>如果要定义一个空的tuple，可以写成<code>()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; t = ()</div><div class="line">&gt;&gt;&gt; t</div><div class="line">()</div></pre></td></tr></table></figure>
<p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">1</div></pre></td></tr></table></figure>
<p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p>
<p>所以，<strong>只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1,)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1,)</div></pre></td></tr></table></figure>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p>
<p>最后来看一个“可变的”tuple：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</div><div class="line">&gt;&gt;&gt; t[2][0] = &apos;X&apos;</div><div class="line">&gt;&gt;&gt; t[2][1] = &apos;Y&apos;</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</div></pre></td></tr></table></figure>
<p>这个tuple定义的时候有3个元素，分别是<code>&#39;a&#39;</code>，<code>&#39;b&#39;</code>和一个list。</p>
<p><strong>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>&#39;a&#39;</code>，就不能改成指向<code>&#39;b&#39;</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</strong></p>
</li>
</ul>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul>
<li><p>list，表(本质是个类)   s2=[1,2,[‘g’]] ,可变. 函数 <strong>range(n)</strong> ，建立一个从0到n-1的表</p>
</li>
<li><p>下表引用 基本样式 下限：上限：步长<br><code>print s1[0:5:2]</code> 从下标0到下标4，每隔2取一个元素，输出为0，2，4<br>so,上限不包括本身。</p>
</li>
<li><p>尾部元素引用 s1[-1] 序列中最后一个元素，s1[-3]序列倒数第三个元素</p>
<p>切片操作十分有用。我们先创建一个0-99的数列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L = list(range(100))</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[0, 1, 2, 3, ..., 99]</div></pre></td></tr></table></figure>
<p>可以通过切片轻松取出某一段数列。比如前10个数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L[:10]</div><div class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div></pre></td></tr></table></figure>
<p>后10个数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L[-10:]</div><div class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</div></pre></td></tr></table></figure>
<p>前11-20个数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L[10:20]</div><div class="line">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</div></pre></td></tr></table></figure>
<p>前10个数，每两个取一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L[:10:2]</div><div class="line">[0, 2, 4, 6, 8]</div></pre></td></tr></table></figure>
<p>所有数，每5个取一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L[::5]</div><div class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</div></pre></td></tr></table></figure>
<p>甚至什么都不写，只写<code>[:]</code>就可以原样复制一个list：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L[:]</div><div class="line">[0, 1, 2, 3, ..., 99]</div></pre></td></tr></table></figure>
</li>
<li><p>tuple也是一种list，唯一区别是tuple不可变。因此，<strong>tuple也可以用切片操作</strong>，只是操作的结果仍是tuple</p>
</li>
<li><p>字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</div><div class="line">&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</div><div class="line">&apos;ACEG&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关于序列的内置函数"><a href="#关于序列的内置函数" class="headerlink" title="关于序列的内置函数"></a>关于序列的内置函数</h4><ul>
<li><p>适用于序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">len(s)         返回： 序列中包含元素的个数</div><div class="line">min(s)         返回： 序列中最小的元素</div><div class="line">max(s)         返回： 序列中最大的元素</div><div class="line">all(s)         返回： True, 如果所有元素都为True的话</div><div class="line">any(s)         返回： True, 如果任一元素为True的话</div></pre></td></tr></table></figure>
</li>
<li><p>查询功能，适用于表和定值表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sum(s)         返回：序列中所有元素的和</div><div class="line"># x为元素值，i为下标(元素在序列中的位置)</div><div class="line"></div><div class="line">s.count(x)     返回： x在s中出现的次数</div><div class="line">s.index(x)     返回： x在s中第一次出现的下标</div></pre></td></tr></table></figure>
</li>
<li><p>只适用于表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># l为一个表, l2为另一个表</div><div class="line"></div><div class="line">l.extend(l2)        在表l的末尾添加表l2的所有元素</div><div class="line">l.append(x)         在l的末尾附加x元素</div><div class="line">l.sort()            对l中的元素排序</div><div class="line">l.reverse()         将l中的元素逆序</div><div class="line">l.pop()             返回：表l的最后一个元素，并在表l中删除该元素</div><div class="line">del l[i]            删除该元素</div><div class="line"></div><div class="line">(以上这些方法都是在原来的表的上进行操作，会对原来的表产生影响，而不是返回一个新表。)</div></pre></td></tr></table></figure>
</li>
<li><p>用于字符串的方法。尽管字符串是定值表的特殊的一种，但字符串(string)类有一些方法是改变字符串的。这些方法的本质不是对原有字符串进行操作，而是删除原有字符串，再建立一个新的字符串，所以并不与定值表的特点相矛盾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#str为一个字符串，sub为str的一个子字符串。s为一个序列，它的元素都是字符串。width为一个整数，用于说明新生成字符串的宽度。</div><div class="line"></div><div class="line">str.count(sub)       返回：sub在str中出现的次数</div><div class="line">str.find(sub)        返回：从左开始，查找sub在str中第一次出现的位置。如果str中不包含sub，返回 -1</div><div class="line"></div><div class="line">str.index(sub)       返回：从左开始，查找sub在str中第一次出现的位置。如果str中不包含sub，举出错误</div><div class="line"></div><div class="line">str.rfind(sub)       返回：从右开始，查找sub在str中第一次出现的位置。如果str中不包含sub，返回 -1</div><div class="line"></div><div class="line">str.rindex(sub)      返回：从右开始，查找sub在str中第一次出现的位置。如果str中不包含sub，举出错误</div><div class="line"></div><div class="line"></div><div class="line">str.isalnum()        返回：True， 如果所有的字符都是字母或数字</div><div class="line">str.isalpha()        返回：True，如果所有的字符都是字母</div><div class="line">str.isdigit()        返回：True，如果所有的字符都是数字</div><div class="line">str.istitle()        返回：True，如果所有的词的首字母都是大写</div><div class="line">str.isspace()        返回：True，如果所有的字符都是空格</div><div class="line">str.islower()        返回：True，如果所有的字符都是小写字母</div><div class="line">str.isupper()        返回：True，如果所有的字符都是大写字母</div><div class="line"></div><div class="line">str.split([sep, [max]])    返回：从左开始，以空格为分割符(separator)，将str分割为多个子字符串，总共分割max次。将所得的子字符串放在一个表中返回。可以str.split(&apos;,&apos;)的方式使用逗号或者其它分割符</div><div class="line"></div><div class="line">str.rsplit([sep, [max]])   返回：从右开始，以空格为分割符(separator)，将str分割为多个子字符串，总共分割max次。将所得的子字符串放在一个表中返回。可以str.rsplit(&apos;,&apos;)的方式使用逗号或者其它分割符</div><div class="line"></div><div class="line">str.join(s)                返回：将s中的元素，以str为分割符，合并成为一个字符串。</div><div class="line"></div><div class="line">str.strip([sub])           返回：去掉字符串开头和结尾的空格。也可以提供参数sub，去掉位于字符串开头和结尾的sub  </div><div class="line"></div><div class="line">str.replace(sub, new_sub)  返回：用一个新的字符串new_sub替换str中的sub</div><div class="line">str.capitalize()           返回：将str第一个字母大写</div><div class="line">str.lower()                返回：将str全部字母改为小写</div><div class="line">str.upper()                返回：将str全部字母改为大写</div><div class="line">str.swapcase()             返回：将str大写字母改为小写，小写改为大写</div><div class="line">str.title()                返回：将str的每个词(以空格分隔)的首字母大写</div><div class="line"></div><div class="line">str.center(width)          返回：长度为width的字符串，将原字符串放入该字符串中心，其它空余位置为空格。</div><div class="line"></div><div class="line">str.ljust(width)           返回：长度为width的字符串，将原字符串左对齐放入该字符串，其它空余位置为空格。</div><div class="line"></div><div class="line">str.rjust(width)           返回：长度为width的字符串，将原字符串右对齐放入该字符串，其它空余位置为空格。</div><div class="line">#str为一个字符串，sub为str的一个子字符串。s为一个序列，它的元素都是字符串。width为一个整数，用于说明新生成字符串的宽度。</div><div class="line"></div><div class="line">str.count(sub)       返回：sub在str中出现的次数</div><div class="line">str.find(sub)        返回：从左开始，查找sub在str中第一次出现的位置。如果str中不包含sub，返回 -1</div><div class="line"></div><div class="line">str.index(sub)       返回：从左开始，查找sub在str中第一次出现的位置。如果str中不包含sub，举出错误</div><div class="line"></div><div class="line">str.rfind(sub)       返回：从右开始，查找sub在str中第一次出现的位置。如果str中不包含sub，返回 -1</div><div class="line"></div><div class="line">str.rindex(sub)      返回：从右开始，查找sub在str中第一次出现的位置。如果str中不包含sub，举出错误</div><div class="line"></div><div class="line"></div><div class="line">str.isalnum()        返回：True， 如果所有的字符都是字母或数字</div><div class="line">str.isalpha()        返回：True，如果所有的字符都是字母</div><div class="line">str.isdigit()        返回：True，如果所有的字符都是数字</div><div class="line">str.istitle()        返回：True，如果所有的词的首字母都是大写</div><div class="line">str.isspace()        返回：True，如果所有的字符都是空格</div><div class="line">str.islower()        返回：True，如果所有的字符都是小写字母</div><div class="line">str.isupper()        返回：True，如果所有的字符都是大写字母</div><div class="line"></div><div class="line">str.split([sep, [max]])    返回：从左开始，以空格为分割符(separator)，将str分割为多个子字符串，总共分割max次。将所得的子字符串放在一个表中返回。可以str.split(&apos;,&apos;)的方式使用逗号或者其它分割符</div><div class="line"></div><div class="line">str.rsplit([sep, [max]])   返回：从右开始，以空格为分割符(separator)，将str分割为多个子字符串，总共分割max次。将所得的子字符串放在一个表中返回。可以str.rsplit(&apos;,&apos;)的方式使用逗号或者其它分割符</div><div class="line"></div><div class="line">str.join(s)                返回：将s中的元素，以str为分割符，合并成为一个字符串。</div><div class="line"></div><div class="line">str.strip([sub])           返回：去掉字符串开头和结尾的空格。也可以提供参数sub，去掉位于字符串开头和结尾的sub  </div><div class="line"></div><div class="line">str.replace(sub, new_sub)  返回：用一个新的字符串new_sub替换str中的sub</div><div class="line">str.capitalize()           返回：将str第一个字母大写</div><div class="line">str.lower()                返回：将str全部字母改为小写</div><div class="line">str.upper()                返回：将str全部字母改为大写</div><div class="line">str.swapcase()             返回：将str大写字母改为小写，小写改为大写</div><div class="line">str.title()                返回：将str的每个词(以空格分隔)的首字母大写</div><div class="line"></div><div class="line">str.center(width)          返回：长度为width的字符串，将原字符串放入该字符串中心，其它空余位置为空格。</div><div class="line"></div><div class="line">str.ljust(width)           返回：长度为width的字符串，将原字符串左对齐放入该字符串，其它空余位置为空格。</div><div class="line"></div><div class="line">str.rjust(width)           返回：长度为width的字符串，将原字符串右对齐放入该字符串，其它空余位置为空格。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>#### </p>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>str是不变对象，而list是可变对象。</p>
<p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</div><div class="line">&gt;&gt;&gt; a.sort()</div><div class="line">&gt;&gt;&gt; a</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</div></pre></td></tr></table></figure>
<p>而对于不可变对象，比如str，对str进行操作呢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; a = &apos;abc&apos;</div><div class="line">&gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;)</div><div class="line">&apos;Abc&apos;</div><div class="line">&gt;&gt;&gt; a</div><div class="line">&apos;abc&apos;</div></pre></td></tr></table></figure>
<p>虽然字符串有个<code>replace()</code>方法，也确实变出了<code>&#39;Abc&#39;</code>，但变量<code>a</code>最后仍是<code>&#39;abc&#39;</code>，应该怎么理解呢？</p>
<p>我们先把代码改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; a = &apos;abc&apos;</div><div class="line">&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;Abc&apos;</div><div class="line">&gt;&gt;&gt; a</div><div class="line">&apos;abc&apos;</div></pre></td></tr></table></figure>
<p>要始终牢记的是，<code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/001389580505217f87b492b060b4b0ea60c8e5e70a1b53c000/0" alt="a-to-str"></p>
<p>当我们调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/001389580620829061e426d429640ddb1d17174a82a7244000/0" alt="a-b-to-2-strs"></p>
<p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//一般写法</div><div class="line">。if(i&gt;0)&#123;</div><div class="line">    x=1;</div><div class="line">    y=1;</div><div class="line">&#125;</div><div class="line"># python 写法</div><div class="line">if i&gt;0</div><div class="line">    x=1;</div><div class="line">    y=1;</div></pre></td></tr></table></figure>
<p>通过缩来实现不同层次<br>一个if结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if i&gt;0</div><div class="line">    i=1</div><div class="line">elif i&lt;0 # 可以写多个elif</div><div class="line">    i=2</div><div class="line">els:</div><div class="line">    i=0</div></pre></td></tr></table></figure></p>
<p>elif可理解为else if。</p>
<p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code>，所以下面程序输出20:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">age = <span class="number">20</span></div><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</div><div class="line">    print(<span class="string">'teenager'</span>)</div><div class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</div><div class="line">    print(<span class="string">'adult'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'kid'</span>)</div></pre></td></tr></table></figure>
<h4 id="真值判断"><a href="#真值判断" class="headerlink" title="真值判断"></a>真值判断</h4><p>if 后判断真值，</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>False</th>
<th>True</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔</td>
<td>Flase(与0等价)</td>
<td>True(与1等价)</td>
</tr>
<tr>
<td>字符串</td>
<td>“” （空字符串）</td>
<td>非空字符串” “(空格)，”a”</td>
</tr>
<tr>
<td>数值</td>
<td>0，0.0</td>
<td>1，0.1 ，-2等</td>
</tr>
<tr>
<td>容器</td>
<td>[],(),{},set()</td>
<td>至少有一个容器对象，[0],(None),[“”]</td>
</tr>
<tr>
<td>None</td>
<td>None</td>
<td>非None对象</td>
</tr>
</tbody>
</table>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> gender==<span class="string">'male'</span>:</div><div class="line">	text=<span class="string">'男'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">	text=<span class="string">'女'</span></div></pre></td></tr></table></figure>
<p>pythonic:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">text=<span class="string">'男'</span> <span class="keyword">if</span> gender==<span class="string">'male'</span> <span class="keyword">else</span> <span class="string">'女'</span></div></pre></td></tr></table></figure>
<h4 id="for-else"><a href="#for-else" class="headerlink" title="for/else"></a>for/else</h4><p>for else 是 Python 中特有的语法格式，else 中的代码在 for 循环遍历完所有元素之后执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">flagfound = <span class="keyword">False</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">    <span class="keyword">if</span> i == theflag:</div><div class="line">        flagfound = <span class="keyword">True</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">    process(i)</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> flagfound:</div><div class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"List argument missing terminal flag."</span>)</div></pre></td></tr></table></figure>
<p>pythonic</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">    <span class="keyword">if</span> i == theflag:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    process(i)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"List argument missing terminal flag."</span>)</div></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><code>for 元素 in 序列：</code><br><code>statement</code></p>
<p>Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; list(range(5))</div><div class="line">[0, 1, 2, 3, 4]</div></pre></td></tr></table></figure>
<h4 id="迭代list-dict"><a href="#迭代list-dict" class="headerlink" title="迭代list/dict"></a>迭代list/dict</h4><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。注意items.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l = &#123;<span class="string">'name'</span>: <span class="string">'aa'</span>, <span class="string">'age'</span>: <span class="number">18</span>,<span class="string">'phone'</span>:<span class="string">'1111111111'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x,y <span class="keyword">in</span> l.items():</div><div class="line"><span class="meta">... </span> print(x,y)</div><div class="line">...</div><div class="line">name aa</div><div class="line">age <span class="number">18</span></div><div class="line">phone <span class="number">1111111111</span></div></pre></td></tr></table></figure>
<p>由于字符串也是可迭代对象，因此，也可以作用于<code>for</code>循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; for ch in &apos;ABC&apos;:</div><div class="line">...     print(ch)</div><div class="line">...</div><div class="line">A</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure>
<p>所以，当我们使用<code>for</code>循环时，只要作用于一个可迭代对象，<code>for</code>循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</div><div class="line"><span class="meta">... </span>    print(i, value)</div><div class="line">...</div><div class="line"><span class="number">0</span> A</div><div class="line"><span class="number">1</span> B</div><div class="line"><span class="number">2</span> C</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,value <span class="keyword">in</span> enumerate(a):</div><div class="line"><span class="meta">... </span> print(i,value)</div><div class="line">...</div><div class="line"><span class="number">0</span> i</div><div class="line"><span class="number">1</span> m</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span> c</div><div class="line"><span class="number">4</span> o</div><div class="line"><span class="number">5</span> m</div><div class="line"><span class="number">6</span> e</div></pre></td></tr></table></figure>
<p>上面的<code>for</code>循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:</div><div class="line">...     print(x, y)</div><div class="line">...</div><div class="line">1 1</div><div class="line">2 4</div><div class="line">3 9</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def square_sum(a,b):</div><div class="line">    c=a+b</div><div class="line">    return c</div></pre></td></tr></table></figure>
<p>def 关键字通知python我们在定义一个函数，没有return时返回none.<br>参数传递，可以sum(1,2),或者sum(a=1,b=1).</p>
<p>###函数参数<br>用<em>收集位置参数，以元祖的形式返回，如果有使用的位置参数，</em>会收集剩下的<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def print_args(a,b,*args)</div><div class="line">    print(&quot;have a&quot;,a)</div><div class="line">    print(&quot;have b&quot;,b)</div><div class="line">    print(&quot;the rest:&quot;,args)</div></pre></td></tr></table></figure></p>
<p>用**可以将参数收集到一个字典中，参数的名字是字典的键，对应参数的值是字典的值。</p>
<p><strong>在python总圆括号意味着调用函数，在没有圆括号的情况下，会把函数当成普通对象</strong></p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight"><table><tr><td class="code"><pre><div class="line"># 定义</div><div class="line">class Bird(object):</div><div class="line">    have_feather = True</div><div class="line">    way_of_reproduction = 'egg'</div><div class="line">    # 方法</div><div class="line">    def move(self,dx,dy):</div><div class="line">    position = [0,0]</div><div class="line">    position[0] = position[0]+dx</div><div class="line">    position[1] = position[1]+dy</div><div class="line">    return position </div><div class="line">    </div><div class="line"># 使用</div><div class="line">summer = Bird()</div><div class="line">print summer.way_of_reproduction</div><div class="line"></div><div class="line"># 继承</div><div class="line">class Chicken(Bird);</div><div class="line">    way_of_move = 'walk'</div></pre></td></tr></table></figure>
<p>方法中有个self，方便我们引用自身对象，无论用或不用，第一个参数必须是self.传参可以不传.这个相当与其他语言中的this，代表这个实例，可以在方法中用本类的属性</p>
<h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line">        self.__name = name</div><div class="line">        self.__score = score</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'%s: %s'</span> % (self.__name, self.__score))</div></pre></td></tr></table></figure>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了，子类也不能访问，只有自己能访问。</p>
<p><code>_abc</code>单下划线是保护变量，子类能访问。外部不能访问。更多看作用域。</p>
<h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><p>只允许对Student实例添加<code>name</code>和<code>age</code>属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</div></pre></td></tr></table></figure>
<p>然后，我们试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 绑定属性'name'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性'age'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性'score'</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></div></pre></td></tr></table></figure>
<p>由于<code>&#39;score&#39;</code>没有被放到<code>__slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; class GraduateStudent(Student):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; g = GraduateStudent()</div><div class="line">&gt;&gt;&gt; g.score = 9999</div></pre></td></tr></table></figure>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h4 id="super-方法"><a href="#super-方法" class="headerlink" title="super()方法"></a>super()方法</h4><p><a href="http://python.jobbole.com/87291/" target="_blank" rel="external">http://python.jobbole.com/87291/</a></p>
<h4 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__()方法"></a><code>__init__()方法</code></h4><p>python中有一些特殊方法，特殊方法的特点是名字前后有两个下划线<br>如果在类中定义了init这个方法，python会自动调用这个方法，这个过程也叫初始化</p>
<p>####<code>__new__()</code>方法</p>
<p><code>__new__</code> 这个方法负责创建类实例，而 <code>__init__</code> 负责初始化类实例 。 <code>__new__</code> 函数可以用来自定义对象的创建，它的第一个参数是这个类的引用，然后是一些构造参数；返回值通常是对象实例的引用。</p>
<p>通常用来判断有没有这个类的实例。</p>
<h4 id="repr-方法"><a href="#repr-方法" class="headerlink" title="__repr__()方法"></a><code>__repr__()</code>方法</h4><p>这个函数，对应repr(object)这个功能。意思是当需要显示一个对象在屏幕上时，将这个对象的属性或者是方法整理成一个可以打印输出的格式。</p>
<p>这个功能与eval也可以对应。打印出的结果直接放到eval里，通常可以获得原来的对象。<br>比如：<br>t1=datetime.datetime.now()<br>print repr(t1)<br>结果是<br>datetime.datetime(2014, 9, 9, 6, 34, 29, 756000)</p>
<h3 id="dir-和-help"><a href="#dir-和-help" class="headerlink" title="dir() 和 help"></a>dir() 和 help</h3><p>dir()可以用来查询一个类或者对象的所有属性 dir(list)<br>help() 来查询相应文档  help（list)</p>
<h3 id="运算符是特殊方法"><a href="#运算符是特殊方法" class="headerlink" title="运算符是特殊方法"></a>运算符是特殊方法</h3><p>使用dir(list)的时候，能看到一个属性，是add()。从形式上看是特殊方法（下划线，下划线）。它特殊在哪呢？<br>这个方法定义了”+”运算符对于list对象的意义，两个list的对象相加时，会进行的操作。<br><code>&gt;&gt;&gt;print [1,2,3] + [5,6,9]</code><br>运算符，比如+, -, &gt;, &lt;, 以及下标引用[start:end]等等，从根本上都是定义在类内部的方法。<br>尝试一下：<br><code>&gt;&gt;&gt;print [1,2,3] - [3,4]</code><br>会有错误信息，说明该运算符“-”没有定义。现在我们继承list类，添加对”-“的定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class superList(list):</div><div class="line">    def __sub__(self, b):</div><div class="line">        a = self[:]     # 这里，self是supeList的对象。由于superList继承于list，它可以利用和list[:]相同的引用方法来表示整个对象。</div><div class="line">        b = b[:]        </div><div class="line">        while len(b) &gt; 0:</div><div class="line">            element_b = b.pop()</div><div class="line">            if element_b in a:</div><div class="line">                a.remove(element_b)</div><div class="line">        return a</div><div class="line"></div><div class="line">print superList([1,2,3]) - superList([3,4])</div></pre></td></tr></table></figure></p>
<p>内置函数len()用来返回list所包含的元素的总数。内置函数<strong>sub</strong>() 定义了“-”的操作：从第一个表中去掉第二个表中出现的元素。如果<strong>sub</strong>() 已经在父类中定义，你又在子类中定义了，那么子类的对象会参考子类的定义，而不会载入父类的定义。任何其他的属性也是这样。</p>
<h3 id="词典（字典dict）"><a href="#词典（字典dict）" class="headerlink" title="词典（字典dict）"></a>词典（字典dict）</h3><p>可以理解为一种key-value的list<br><code>dic = {&#39;tom&#39;:11,&#39;sam&#39;:12,&#39;lily&#39;:100}</code><br>与表不同的是，不能通过下下标来引用，要通过键来引用<br><code>print dic[&#39;tom&#39;]</code><br>循环词典：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dic = &#123;&apos;lilei&apos;: 90, &apos;lily&apos;: 100, &apos;sam&apos;: 57, &apos;tom&apos;: 90&#125;</div><div class="line">for key in dic:</div><div class="line">    print dic[key]</div></pre></td></tr></table></figure></p>
<p>判断存在：</p>
<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Thomas&apos; in d</div><div class="line">False</div></pre></td></tr></table></figure>
<p>二是通过dict提供的get方法，如果key不存在，可以返回None，字符串或者自己指定的value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</div><div class="line"><span class="number">-1</span></div></pre></td></tr></table></figure>
<p>注意：返回<code>None</code>的时候Python的交互式命令行不显示结果。</p>
<p>牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。</p>
<p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt;print dic.keys()           # 返回dic所有的键</div><div class="line">&gt;&gt;&gt;print dic.values()         # 返回dic所有的值</div><div class="line">&gt;&gt;&gt;print dic.items()          # 返回dic所有的元素（键值对）</div><div class="line">&gt;&gt;&gt;dic.clear()                # 清空dic，dict变为&#123;&#125;</div><div class="line">&gt;&gt;&gt;del dic[&apos;tom&apos;]             # 删除 dic 的‘tom’元素</div><div class="line">del是Python中保留的关键字，用于删除对象。</div><div class="line">与表类似，你可以用len()查询词典中的元素总数。</div><div class="line">&gt;&gt;&gt;print len(dic)</div></pre></td></tr></table></figure>
<h4 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h4><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>set ( 集 合 ) 。 集 合 是 一 个 无 序 不 重 复 元素 的 集 。 基 本 功 能 包 括 关 系 测 试 和 消 除 重 复 元 素 。 集 合 对 象 还 支 持 union( 联<br>合),intersection(交),difference(差)和 sysmmetric difference(对称差集)等数学运算。<br>大括号或 set() 函数可以用来创建集合。</p>
<p>python中的set基于哈希表实现，存取时间可看做O(1)，但是没有办法高效的完成顺序相关的操作(比如找前驱后继，最大最小值等等)，所以认为是“无序”的。</p>
<p> 注意:想要创建空集合,你必须使用set() 而不是 {} 。{}用于创建空字典；</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([1, 2, 3])</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;1, 2, 3&#125;</div></pre></td></tr></table></figure>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
<p>重复元素在set中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;1, 2, 3&#125;</div></pre></td></tr></table></figure>
<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; s.add(4)</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;1, 2, 3, 4&#125;</div><div class="line">&gt;&gt;&gt; s.add(4)</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;1, 2, 3, 4&#125;</div></pre></td></tr></table></figure>
<p>通过<code>remove(key)</code>方法可以删除元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; s.remove(4)</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;1, 2, 3&#125;</div></pre></td></tr></table></figure>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</div><div class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</div><div class="line">&gt;&gt;&gt; s1 &amp; s2</div><div class="line">&#123;2, 3&#125;</div><div class="line">&gt;&gt;&gt; s1 | s2</div><div class="line">&#123;1, 2, 3, 4&#125;</div></pre></td></tr></table></figure>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a=set()</div><div class="line">a.add(1)</div><div class="line">a.add([3,4,5])</div><div class="line">print(a) #TypeError: unhashable type: &apos;list&apos;</div></pre></td></tr></table></figure>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>创建文件<pre><code>`对象名 = open(文件名，模式)`
常用的模式：
</code></pre><ul>
<li>r 打开只读文件，该文件必须存在。</li>
<li>r+ 打开可读写的文件，该文件必须存在。</li>
<li>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则 建立该文件。</li>
<li>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。</li>
<li>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。<br>上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。windows下文件是二进制，而linux不需要区分二进制和文件。</li>
</ul>
</li>
<li><p>读取 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">content = f.read(N)          # 读取N bytes的数据</div><div class="line">content = f.readline()       # 读取一行</div><div class="line">content = f.readlines()      # 读取所有行，储存在列表中，每个元素是一行。</div></pre></td></tr></table></figure>
</li>
<li><p>写入<br><code>f.write(&#39;I like apple!\n&#39;)      # 将&#39;I like apple&#39;写入文件并换行</code></p>
</li>
<li>关闭文件<br><code>f.close()</code></li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p>
<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<p>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_1</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, %s'</span> % name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_2</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hi, %s'</span> % name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(name) &gt; <span class="number">3</span>:</div><div class="line">        <span class="keyword">return</span> _private_1(name)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> _private_2(name)</div></pre></td></tr></table></figure>
<p>我们在模块里公开<code>greeting()</code>函数，而把内部逻辑用private函数隐藏起来了，这样，调用<code>greeting()</code>函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</p>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>相当与引用其他.py文件，类似于java中的引入包。<br><code>import 文件名</code><br>使用其他文件中的对象：<code>文件名(模块).对象</code><br>其他引入方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import a as b             # 引入模块a，并将模块a重命名为b</div><div class="line">from a import function1   # 从模块a中引入function1对象。调用a中对象时，我们不用再说明模块，即直接使用function1，而不是a.function1。</div><div class="line">from a import *           # 从模块a中引入所有对象。调用a中对象时，我们不用再说明模块，即直接使用对象，而不是a.对象。</div></pre></td></tr></table></figure></p>
<h3 id="模块包"><a href="#模块包" class="headerlink" title="模块包"></a>模块包</h3><p>可以将功能相似的模块放在同一个文件夹（比如说this_dir）中，构成一个模块包。通过</p>
<p><code>import this_dir.module</code><br>引入this_dir文件夹中的module模块。</p>
<p>该文件夹中必须包含一个 <code>__init__.py</code> 的文件，提醒Python，该文件夹为一个模块包。<strong>init</strong>.py 可以是一个空文件。</p>
<h3 id="包裹传递"><a href="#包裹传递" class="headerlink" title="包裹传递"></a>包裹传递</h3><ul>
<li>在传递函数的参数时，我们不知道有多少个参数，这时可以传递包裹<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def func(*name):</div><div class="line">    print type(name)</div><div class="line">    print name</div><div class="line"></div><div class="line">func(1,4,6)</div><div class="line">func(5,6,7,1,2,3)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>所有的参数被name收集，根据位置合并成一个元组(tuple)，这就是包裹位置传递。</p>
<ul>
<li>包裹关键字传递：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def func(**dict):</div><div class="line">    print type(dict)</div><div class="line">    print dict</div><div class="line"></div><div class="line">func(a=1,b=9)</div><div class="line">func(m=2,n=1,c=11)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与上面一个例子类似，dict是一个字典，收集所有的关键字，传递给函数func。为了提醒Python，参数dict是包裹关键字传递所用的字典，在dict前加 <em> </em></p>
<ul>
<li>定义的时候没有定义包裹也可以在传递的时候用：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def func(a,b,c):</div><div class="line">    print a,b,c</div><div class="line"></div><div class="line">args = (1,3,4)</div><div class="line">func(*args)</div><div class="line"># 相应的：</div><div class="line">dict = &#123;&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3&#125;</div><div class="line">func(**dict)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><ul>
<li><p>range()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">S = &apos;abcdefghijk&apos;</div><div class="line">for i in range(0,len(S),2):</div><div class="line">    print S[i]</div></pre></td></tr></table></figure>
</li>
<li><p>enumerate()<br>利用enumerate()函数，可以在每次循环中同时得到下标和元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">S = &apos;abcdefghijk&apos;</div><div class="line">for (index,char) in enumerate(S):</div><div class="line">    print index</div><div class="line">    print char</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实际上，enumerate()在每次循环中，返回的是一个包含两个元素的定值表(tuple)，两个元素分别赋予index和char。</p>
<ul>
<li>zip()<br>如果你多个等长的序列，然后想要每次循环时从各个序列分别取出一个元素，可以利用zip()方便地实现：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ta = [1,2,3]</div><div class="line">tb = [9,8,7]</div><div class="line">tc = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</div><div class="line">for (a,b,c) in zip(ta,tb,tc):</div><div class="line">    print(a,b,c)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>zip()函数的功能，就是从多个列表中，依次各取出一个元素。每次取出的(来自不同列表的)元素合成一个元组，合并成的元组放入zip()返回的列表中。zip()函数起到了聚合列表的功能。<br>分解聚合后的列表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ta = [1,2,3]</div><div class="line">tb = [9,8,7]</div><div class="line"></div><div class="line"># cluster</div><div class="line">zipped = zip(ta,tb)</div><div class="line">print(zipped)</div><div class="line"></div><div class="line"># decompose</div><div class="line">na, nb = zip(*zipped)</div><div class="line">print(na, nb)</div></pre></td></tr></table></figure></p>
<h3 id="循环对象"><a href="#循环对象" class="headerlink" title="循环对象"></a>循环对象</h3><p>在python3中有个<strong>next</strong>() 方法，进行到下个结果，最后出现StopIteration错误<br>假设有个test.txt的文件：、<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1234</div><div class="line">abcd</div><div class="line">efg</div></pre></td></tr></table></figure></p>
<p>运行python命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt;f = open(&apos;test.txt&apos;)</div><div class="line">&gt;&gt;&gt;f.next()</div><div class="line">&gt;&gt;&gt;f.next()</div><div class="line">..#直到最后出现stoplteration.</div></pre></td></tr></table></figure></p>
<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>举个例子，要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; list(range(1, 11))</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div></pre></td></tr></table></figure>
<p>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L = []</div><div class="line">&gt;&gt;&gt; for x in range(1, 11):</div><div class="line">...    L.append(x * x)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</div><div class="line">[4, 16, 36, 64, 100]</div></pre></td></tr></table></figure>
<p>还可以使用两层循环，可以生成全排列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</div><div class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</div></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
<p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</div><div class="line">&gt;&gt;&gt; L</div><div class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</div><div class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</div><div class="line">&gt;&gt;&gt; g</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</div></pre></td></tr></table></figure>
<p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个generator。</p>
<p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？当然是for循环。</p>
<p>用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">ef fib(max):</div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        <span class="keyword">yield</span> b</div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</div><div class="line"><span class="meta">... </span>        x = next(g)</div><div class="line"><span class="meta">... </span>        print(<span class="string">'g:'</span>, x)</div><div class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</div><div class="line"><span class="meta">... </span>        print(<span class="string">'Generator return value:'</span>, e.value)</div><div class="line"><span class="meta">... </span>        <span class="keyword">break</span></div><div class="line">...</div><div class="line">g: <span class="number">1</span></div><div class="line">g: <span class="number">1</span></div><div class="line">g: <span class="number">2</span></div><div class="line">g: <span class="number">3</span></div><div class="line">g: <span class="number">5</span></div><div class="line">g: <span class="number">8</span></div><div class="line">Generator <span class="keyword">return</span> value: done</div></pre></td></tr></table></figure>
<hr>
<p>上面是定义生生成器的一种方法，还有一种方法：</p>
<p>著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
<p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def fib(max):</div><div class="line">    n, a, b = 0, 0, 1</div><div class="line">    while n &lt; max:</div><div class="line">        print(b)</div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + 1</div><div class="line">    return &apos;done&apos;</div></pre></td></tr></table></figure>
<p><em>注意</em>，赋值语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a, b = b, a + b</div></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">t = (b, a + b) # t是一个tuple</div><div class="line">a = t[0]</div><div class="line">b = t[1]</div></pre></td></tr></table></figure>
<p>但不必显式写出临时变量t就可以赋值。仔细观察，可以看出，<code>fib</code>函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p>
<p>也就是说，上面的函数和generator仅一步之遥。要把<code>fib</code>函数变成generator，只需要把<code>print(b)</code>改为<code>yield b</code>就可以了。</p>
<p>这就是定义generator的另一种方法。</p>
<p><strong>如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator。</strong></p>
<p>generator的主要目的是构建一个用户自定义的循环对象，编写方法和函数相似，只是把return的地方改为yield，每次运行到生成器的时候在yield处暂停，返回yield后面值，当再次调用的时候，从暂停的地方继续运行，每次循环使用一个yield返回的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def gen():</div><div class="line">    a = 100</div><div class="line">    yield a</div><div class="line">    a = a*8</div><div class="line">    yield a</div><div class="line">    yield 1000</div></pre></td></tr></table></figure></p>
<h4 id="生成器表达式："><a href="#生成器表达式：" class="headerlink" title="生成器表达式："></a>生成器表达式：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def gen():</div><div class="line">    for i in range(4):</div><div class="line">        yield i</div></pre></td></tr></table></figure>
<p>等价于：<br><code>G=(x for x in range(4))</code></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p>
<p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p>
<p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p>
<p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p>
<p>而生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</div><div class="line">True</div></pre></td></tr></table></figure>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><h4 id="lambda表达"><a href="#lambda表达" class="headerlink" title="lambda表达"></a>lambda表达</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def func(x,y):</div><div class="line">    return x+y</div><div class="line">----------------</div><div class="line">func = lambda x,y:x+y</div></pre></td></tr></table></figure>
<p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p>
<h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h4><p>它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x*x</div><div class="line"><span class="keyword">print</span> map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</div><div class="line">输出结果：</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure>
<p>仍然可以接受两个list:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">re = map((lambda x,y: x+y),[1,2,3],[6,7,9])</div></pre></td></tr></table></figure>
<p>map()将每次从两个表中分别取出一个元素，带入lambda所定义的函数。结果返回到表re中。<br>map函数第一个参数是一个函数对象。</p>
<h4 id="filter-函数-根据条件判断"><a href="#filter-函数-根据条件判断" class="headerlink" title="filter()函数(根据条件判断)"></a>filter()函数(根据条件判断)</h4><p>filter函数的第一个参数也是一个函数对象。它也是将作为参数的函数对象作用于多个元素。如果函数对象返回的是True，则该次的元素被储存于返回的表中。 filter通过读入的函数来筛选数据。同样，在Python 3.X中，filter返回的不是表，而是循环对象。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">if</span> a &gt; <span class="number">100</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> filter(func,[<span class="number">10</span>,<span class="number">56</span>,<span class="number">101</span>,<span class="number">500</span>])</div></pre></td></tr></table></figure></p>
<h4 id="reduce-函数-累积传参）"><a href="#reduce-函数-累积传参）" class="headerlink" title="reduce()函数(累积传参）"></a>reduce()函数(累积传参）</h4><p><code>print reduce((lambda x,y: x+y),[1,2,5,7,9])</code><br>相当于((1+2)+5)+7)+9<br>reduce()函数在3.0里面不能直接用的，它被定义在了functools包里面，需要引入包。</p>
<p>比方说对一个序列求和，就可以用<code>reduce</code>实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<p>当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用<code>reduce</code>。</p>
<p>但是如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>，<code>reduce</code>就可以派上用场：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure>
<p>这个例子本身没多大用处，但是，如果考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, map(char2num, <span class="string">'13579'</span>))</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted()</code>函数就可以对list进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</div><div class="line">[-21, -12, 5, 9, 36]</div></pre></td></tr></table></figure>
<p>此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</div><div class="line">[5, 9, -12, -21, 36]</div></pre></td></tr></table></figure>
<p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过<code>key=abs</code>处理过的list：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">list = [36, 5, -12, 9, -21]</div><div class="line"></div><div class="line">keys = [36, 5,  12, 9,  21]</div></pre></td></tr></table></figure>
<p>然后<code>sorted()</code>函数按照keys进行排序，并按照对应关系返回list相应的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">keys排序结果 =&gt; [5, 9,  12,  21, 36]</div><div class="line">                |  |    |    |   |</div><div class="line">最终结果     =&gt; [5, 9, -12, -21, 36]</div></pre></td></tr></table></figure>
<p>我们再看一个字符串排序的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])</div><div class="line">[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]</div></pre></td></tr></table></figure>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>这样，我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower)</div><div class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</div></pre></td></tr></table></figure>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</div><div class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</div></pre></td></tr></table></figure>
<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。key是一个函数，自己也可以按功能定义。</p>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<ul>
<li><p>高阶函数</p>
<p>函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def add(x, y, f):</div><div class="line">    return f(x) + f(y)</div></pre></td></tr></table></figure>
<p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">x = -5</div><div class="line">y = 6</div><div class="line">f = abs</div><div class="line">f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11</div><div class="line">return 11</div></pre></td></tr></table></figure>
</li>
</ul>
<p>编写高阶函数，就是让函数的参数能够接收别的函数</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></div><div class="line">        ax = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</div><div class="line">            ax = ax + n</div><div class="line">        <span class="keyword">return</span> ax</div><div class="line">    <span class="keyword">return</span> sum</div></pre></td></tr></table></figure>
<p>在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>注意到返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是<strong>直到调用了f()`</strong>才执行。我们来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">             <span class="keyword">return</span> i*i</div><div class="line">        fs.append(f)</div><div class="line">    <span class="keyword">return</span> fs</div></pre></td></tr></table></figure>
<p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; f1()</div><div class="line">9</div><div class="line">&gt;&gt;&gt; f2()</div><div class="line">9</div><div class="line">&gt;&gt;&gt; f3()</div><div class="line">9</div></pre></td></tr></table></figure>
<p>全部都是<code>9</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p>
<p>为什么要闭包？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">funx</span><span class="params">()</span>:</span></div><div class="line">    x=<span class="number">5</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funy</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">nonlocal</span> x</div><div class="line">        x+=<span class="number">1</span></div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">return</span> funy</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a=funx()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a()</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a()</div><div class="line"><span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a()</div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#19&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    x</div><div class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>我们会发现，funx中的x变量原本仅仅是funx的一个局部变量。但是形成了闭包之后，它的行为就好像是一个全局变量一样。但是最后的错误说明x并不是一个全局变量。其实这就是闭包的一个十分浅显的作用，形成闭包之后，闭包变量能够随着闭包函数的调用而实时更新，就好像是一个全局变量那样。（注意我们上面的a=funx()，a实际上应该是funy，所以a称为闭包）</p>
<h5 id="global-and-nonlocal"><a href="#global-and-nonlocal" class="headerlink" title="global and nonlocal"></a>global and nonlocal</h5><p>global关键字用来在函数或其他局部作用域中使用全局变量。但是如果不修改全局变量也可以不使用global关键字。</p>
<p>nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'2015-3-25'</span>)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = now</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f()</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kw)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line">--------------</div><div class="line"><span class="meta">@log		#把@log放到now()函数的定义处，相当于执行了语句：now = log(now)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2015-3-25'</span>)</div><div class="line">   </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">call now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure>
<p>增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p>
<h5 id="property"><a href="#property" class="headerlink" title="@property"></a><code>@property</code></h5><p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._score</div><div class="line"></div><div class="line"><span class="meta">    @score.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</div><div class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</div><div class="line">        self._score = value</div></pre></td></tr></table></figure>
<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; s = Student()</div><div class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</div><div class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</div><div class="line">60</div><div class="line">&gt;&gt;&gt; s.score = 9999</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">ValueError: score must between 0 ~ 100!</div></pre></td></tr></table></figure>
<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Student(object):</div><div class="line"></div><div class="line">    @property</div><div class="line">    def birth(self):</div><div class="line">        return self._birth</div><div class="line"></div><div class="line">    @birth.setter</div><div class="line">    def birth(self, value):</div><div class="line">        self._birth = value</div><div class="line"></div><div class="line">    @property</div><div class="line">    def age(self):</div><div class="line">        return 2015 - self._birth</div></pre></td></tr></table></figure>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<strong>只读</strong>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>Python的<code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</p>
<p><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;12345&apos;)</div><div class="line">12345</div></pre></td></tr></table></figure>
<p>但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;12345&apos;, base=8)</div><div class="line">5349</div><div class="line">&gt;&gt;&gt; int(&apos;12345&apos;, 16)</div><div class="line">74565</div></pre></td></tr></table></figure>
<p>假设要转换大量的二进制字符串，每次都传入<code>int(x, base=2)</code>非常麻烦，于是，我们想到，可以定义一个<code>int2()</code>的函数，默认把<code>base=2</code>传进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def int2(x, base=2):</div><div class="line">    return int(x, base)</div></pre></td></tr></table></figure>
<p>这样，我们转换二进制就非常方便了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</div><div class="line">64</div><div class="line">&gt;&gt;&gt; int2(&apos;1010101&apos;)</div><div class="line">85</div></pre></td></tr></table></figure>
<p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; import functools</div><div class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</div><div class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</div><div class="line">64</div><div class="line">&gt;&gt;&gt; int2(&apos;1010101&apos;)</div><div class="line">85</div></pre></td></tr></table></figure>
<p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<p>注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为<code>2</code>，但也可以在函数调用时传入其他值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;, base=10)</div><div class="line">1000000</div></pre></td></tr></table></figure>
<h3 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">    ...</div><div class="line">except exception1:</div><div class="line">    ...</div><div class="line">except exception2 as e:</div><div class="line">    ...</div><div class="line">except:</div><div class="line">    ...</div><div class="line">else:</div><div class="line">    ...</div><div class="line">finally:</div><div class="line">    ...</div></pre></td></tr></table></figure>
<ul>
<li><p>try - 有异常 - except 1 或者 2，都没有，到except - finally</p>
</li>
<li><p>try - 无异常 - else - finally</p>
</li>
<li><p>打印异常 print(exception1),print(e)</p>
</li>
<li><p>看异常的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import sys</div><div class="line">try:</div><div class="line">    raise</div><div class="line">except:</div><div class="line">    t,v,tb = sys.exc_info()</div><div class="line">    print(t,v)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h4 id="抛异常"><a href="#抛异常" class="headerlink" title="抛异常"></a>抛异常</h4><p><code>raise StopIteration</code><br>StopIteration是一个类。抛出异常时，会自动有一个中间环节，就是生成StopIteration的一个对象。Python实际上抛出的，是这个对象。当然，也可以自行生成对象:<br><code>raise StopIteration()</code></p>
<h3 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#== 和 is的差别，==比较的是内容，is比较的是引用。</div></pre></td></tr></table></figure>
<h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>钩子来源于英文词Hook，在windows系统中，一切皆消息，比如按了一下键盘，也是一个消息，Hook的意思是勾住，也就是在消息过去之前，可以先把消息勾住，不让其传递，你可以优先处理，也即这项技术就是提供了一个入口，能够针对不同的消息或者API在执行前，先执行你的操作，你的操作也称为「钩子函数」。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>不要用windows自带的笔记本写py,它会自动加utf-8 bom。导致莫名的错误。</li>
<li><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; not True</div><div class="line">False</div><div class="line">&gt;&gt;&gt; not False</div><div class="line">True</div><div class="line">&gt;&gt;&gt; not 1 &gt; 2</div><div class="line">True</div></pre></td></tr></table></figure>
<ul>
<li><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p>
</li>
<li><p>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a = 123 # a是整数</div><div class="line">print(a)</div><div class="line">a = &apos;ABC&apos; # a变为字符串</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，</p>
</li>
<li><p>解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是<code>/</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 10 / 3</div><div class="line">3.3333333333333335</div></pre></td></tr></table></figure>
<p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 9 / 3</div><div class="line">3.0</div></pre></td></tr></table></figure>
<p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 10 // 3</div><div class="line">3</div></pre></td></tr></table></figure>
<p>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p>
<p>因为<code>//</code>除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 10 % 3</div><div class="line">1</div></pre></td></tr></table></figure>
<p>无论整数做<code>//</code>除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">print(<span class="string">'3 / 2 ='</span>, <span class="number">3</span> / <span class="number">2</span>)       <span class="comment">#1.5</span></div><div class="line">print(<span class="string">'3 // 2 ='</span>, <span class="number">3</span> // <span class="number">2</span>) 	  <span class="comment">#1</span></div><div class="line">print(<span class="string">'3 / 2.0 ='</span>, <span class="number">3</span> / <span class="number">2.0</span>)   <span class="comment">#1.5</span></div><div class="line">print(<span class="string">'3 // 2.0 ='</span>, <span class="number">3</span> // <span class="number">2.0</span>) <span class="comment"># 1.0</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>错误：<code>IndentationError: expected an indented block</code></p>
<p> 没有缩进块，或者缩进错误。</p>
</li>
<li><p><code>pass</code>还可以用在其他语句里，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>缺少了<code>pass</code>，代码运行就会有语法错误。</p>
</li>
<li><p>使用内建的<code>isinstance</code>函数可以判断一个变量是不是字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; x = &apos;abc&apos;</div><div class="line">&gt;&gt;&gt; y = 123</div><div class="line">&gt;&gt;&gt; isinstance(x, str)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(y, str)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import Iterable</div><div class="line">&gt;&gt;&gt; isinstance([], Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance(100, Iterable)</div><div class="line">False</div></pre></td></tr></table></figure>
</li>
<li><p>一般使用type()函数来看数据的类型：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">b=(x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</div><div class="line">print(type(a)) <span class="comment">#&lt;class 'tuple'&gt;</span></div><div class="line">print(type(b)) <span class="comment">#&lt;class 'generator'&gt;</span></div></pre></td></tr></table></figure>
<p> ​</p>
</li>
</ul>

                <hr>
                
                <!-- 多说 Share start -->
                <div class="ds-share"
                     style="text-align: right"
                     data-thread-key="2017/01/30/python基础整理/"
                     data-title="python基础整理"
                     data-url="https://clayandmore.github.io/2017/01/30/python基础整理/"
                     data-images=""
                     data-content="python的哲学：
用一种方法，最好是只有一种方法来做一件事。
linux 命令行将以\$开... | Claymore&#39;s blog ">
                    <div class="ds-share-inline">
                        <ul class="ds-share-icons-16">
                            <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                            <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                            <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                            <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                        </ul>
                        <div class="ds-share-icons-more">
                        </div>
                    </div>
                    <hr>
                </div>
                <!-- 多说 Share end-->
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/01/30/python进阶整理/" data-toggle="tooltip" data-placement="top"
                           title="python进阶整理">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/01/29/win10优盘重装系统/" data-toggle="tooltip" data-placement="top"
                           title="win10优盘重装系统">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                         data-thread-key="2017/01/30/python基础整理/"
                         data-title="python基础整理"
                         data-url="https://clayandmore.github.io/2017/01/30/python基础整理/">
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器"><span class="toc-text">解释器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出和输入"><span class="toc-text">输出和输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化"><span class="toc-text">格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#format"><span class="toc-text">format</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列"><span class="toc-text">序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#切片"><span class="toc-text">切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于序列的内置函数"><span class="toc-text">关于序列的内置函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可变对象"><span class="toc-text">不可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件判断"><span class="toc-text">条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#真值判断"><span class="toc-text">真值判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三目运算符"><span class="toc-text">三目运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-else"><span class="toc-text">for/else</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代"><span class="toc-text">迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代list-dict"><span class="toc-text">迭代list/dict</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访问限制"><span class="toc-text">访问限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slots"><span class="toc-text">__slots__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-方法"><span class="toc-text">super()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-方法"><span class="toc-text">__init__()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repr-方法"><span class="toc-text">__repr__()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dir-和-help"><span class="toc-text">dir() 和 help</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符是特殊方法"><span class="toc-text">运算符是特殊方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#词典（字典dict）"><span class="toc-text">词典（字典dict）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#集合set"><span class="toc-text">集合set</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件操作"><span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块"><span class="toc-text">模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块包"><span class="toc-text">模块包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包裹传递"><span class="toc-text">包裹传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环设计"><span class="toc-text">循环设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环对象"><span class="toc-text">循环对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表生成式"><span class="toc-text">列表生成式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器"><span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器表达式："><span class="toc-text">生成器表达式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数-1"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda表达"><span class="toc-text">lambda表达</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-函数"><span class="toc-text">map()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter-函数-根据条件判断"><span class="toc-text">filter()函数(根据条件判断)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce-函数-累积传参）"><span class="toc-text">reduce()函数(累积传参）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sorted"><span class="toc-text">sorted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#global-and-nonlocal"><span class="toc-text">global and nonlocal</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#property"><span class="toc-text">@property</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#偏函数"><span class="toc-text">偏函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误和异常"><span class="toc-text">错误和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#抛异常"><span class="toc-text">抛异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相等比较"><span class="toc-text">相等比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子"><span class="toc-text">钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-text">注意</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#python"
                           title="python">python</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://lfkid.github.io/">锋</a></li>
                        
                        <li><a href="https://clayandmore.github.io/">自我测试</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User by Hux
    var _user = 'claymoreforblog';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user};
    (function () {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->





<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/claymoreTT">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/wangyu-1994">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/clayandmore">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Claymore 2017
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://clayandmore.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','null','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://ojynuthay.bkt.clouddn.com/header.jpg">
</body>

</html>
